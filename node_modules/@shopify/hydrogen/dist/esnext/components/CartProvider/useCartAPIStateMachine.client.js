import { useMachine } from '@xstate/react/fsm';
import { createMachine, assign } from '@xstate/fsm';
import { flattenConnection } from '../../utilities/flattenConnection/index.js';
import { useCartActions } from './CartActions.client.js';
import { useMemo } from 'react';
function invokeCart(action, options) {
    return {
        entry: [
            ...(options?.entryActions || []),
            assign({
                lastValidCart: (context) => context?.cart,
            }),
            'onCartActionEntry',
            'onCartActionOptimisticUI',
            action,
        ],
        on: {
            RESOLVE: {
                target: options?.resolveTarget || 'idle',
                actions: [
                    assign({
                        prevCart: (context) => context?.lastValidCart,
                        cart: (_, event) => event?.payload?.cart,
                        rawCartResult: (_, event) => event?.payload?.rawCartResult,
                        errors: (_) => undefined,
                    }),
                ],
            },
            ERROR: {
                target: options?.errorTarget || 'error',
                actions: [
                    assign({
                        prevCart: (context) => context?.lastValidCart,
                        cart: (context, _) => context?.lastValidCart,
                        errors: (_, event) => event?.payload?.errors,
                    }),
                ],
            },
            CART_COMPLETED: {
                target: 'cartCompleted',
                actions: assign({
                    prevCart: (_) => undefined,
                    cart: (_) => undefined,
                    lastValidCart: (_) => undefined,
                    rawCartResult: (_) => undefined,
                    errors: (_) => undefined,
                }),
            },
        },
        exit: ['onCartActionComplete', ...(options?.exitActions || [])],
    };
}
const INITIALIZING_CART_EVENTS = {
    CART_FETCH: {
        target: 'cartFetching',
    },
    CART_CREATE: {
        target: 'cartCreating',
    },
    CART_SET: {
        target: 'idle',
        actions: [
            assign({
                rawCartResult: (_, event) => event.payload.cart,
                cart: (_, event) => cartFromGraphQL(event.payload.cart),
            }),
        ],
    },
};
const UPDATING_CART_EVENTS = {
    CARTLINE_ADD: {
        target: 'cartLineAdding',
    },
    CARTLINE_UPDATE: {
        target: 'cartLineUpdating',
    },
    CARTLINE_REMOVE: {
        target: 'cartLineRemoving',
    },
    NOTE_UPDATE: {
        target: 'noteUpdating',
    },
    BUYER_IDENTITY_UPDATE: {
        target: 'buyerIdentityUpdating',
    },
    CART_ATTRIBUTES_UPDATE: {
        target: 'cartAttributesUpdating',
    },
    DISCOUNT_CODES_UPDATE: {
        target: 'discountCodesUpdating',
    },
};
function createCartMachine(initialCart) {
    return createMachine({
        id: 'Cart',
        initial: initialCart ? 'idle' : 'uninitialized',
        context: {
            cart: initialCart && cartFromGraphQL(initialCart),
        },
        states: {
            uninitialized: {
                on: INITIALIZING_CART_EVENTS,
            },
            cartCompleted: {
                on: INITIALIZING_CART_EVENTS,
            },
            initializationError: {
                on: INITIALIZING_CART_EVENTS,
            },
            idle: {
                on: { ...INITIALIZING_CART_EVENTS, ...UPDATING_CART_EVENTS },
            },
            error: {
                on: { ...INITIALIZING_CART_EVENTS, ...UPDATING_CART_EVENTS },
            },
            cartFetching: invokeCart('cartFetchAction', {
                errorTarget: 'initializationError',
            }),
            cartCreating: invokeCart('cartCreateAction', {
                errorTarget: 'initializationError',
            }),
            cartLineRemoving: invokeCart('cartLineRemoveAction'),
            cartLineUpdating: invokeCart('cartLineUpdateAction'),
            cartLineAdding: invokeCart('cartLineAddAction'),
            noteUpdating: invokeCart('noteUpdateAction'),
            buyerIdentityUpdating: invokeCart('buyerIdentityUpdateAction'),
            cartAttributesUpdating: invokeCart('cartAttributesUpdateAction'),
            discountCodesUpdating: invokeCart('discountCodesUpdateAction'),
        },
    });
}
export function useCartAPIStateMachine({ numCartLines, onCartActionEntry, onCartActionOptimisticUI, onCartActionComplete, data: cart, cartFragment, countryCode, }) {
    const { cartFetch, cartCreate, cartLineAdd, cartLineUpdate, cartLineRemove, noteUpdate, buyerIdentityUpdate, cartAttributesUpdate, discountCodesUpdate, } = useCartActions({
        numCartLines,
        cartFragment,
        countryCode,
    });
    const cartMachine = useMemo(() => createCartMachine(cart), [cart]);
    const [state, send, service] = useMachine(cartMachine, {
        actions: {
            cartFetchAction: async (_, event) => {
                if (event.type !== 'CART_FETCH')
                    return;
                const { data, errors } = await cartFetch(event?.payload?.cartId);
                const resultEvent = eventFromFetchResult(event, data?.cart, errors);
                send(resultEvent);
            },
            cartCreateAction: async (_, event) => {
                if (event.type !== 'CART_CREATE')
                    return;
                const { data, errors } = await cartCreate(event?.payload);
                const resultEvent = eventFromFetchResult(event, data?.cartCreate?.cart, errors);
                send(resultEvent);
            },
            cartLineAddAction: async (context, event) => {
                if (event.type !== 'CARTLINE_ADD' || !context?.cart?.id)
                    return;
                const { data, errors } = await cartLineAdd(context.cart.id, event.payload.lines);
                const resultEvent = eventFromFetchResult(event, data?.cartLinesAdd?.cart, errors);
                send(resultEvent);
            },
            cartLineUpdateAction: async (context, event) => {
                if (event.type !== 'CARTLINE_UPDATE' || !context?.cart?.id)
                    return;
                const { data, errors } = await cartLineUpdate(context.cart.id, event.payload.lines);
                const resultEvent = eventFromFetchResult(event, data?.cartLinesUpdate?.cart, errors);
                send(resultEvent);
            },
            cartLineRemoveAction: async (context, event) => {
                if (event.type !== 'CARTLINE_REMOVE' || !context?.cart?.id)
                    return;
                const { data, errors } = await cartLineRemove(context.cart.id, event.payload.lines);
                const resultEvent = eventFromFetchResult(event, data?.cartLinesRemove?.cart, errors);
                send(resultEvent);
            },
            noteUpdateAction: async (context, event) => {
                if (event.type !== 'NOTE_UPDATE' || !context?.cart?.id)
                    return;
                const { data, errors } = await noteUpdate(context.cart.id, event.payload.note);
                const resultEvent = eventFromFetchResult(event, data?.cartNoteUpdate?.cart, errors);
                send(resultEvent);
            },
            buyerIdentityUpdateAction: async (context, event) => {
                if (event.type !== 'BUYER_IDENTITY_UPDATE' || !context?.cart?.id)
                    return;
                const { data, errors } = await buyerIdentityUpdate(context.cart.id, event.payload.buyerIdentity);
                const resultEvent = eventFromFetchResult(event, data?.cartBuyerIdentityUpdate?.cart, errors);
                send(resultEvent);
            },
            cartAttributesUpdateAction: async (context, event) => {
                if (event.type !== 'CART_ATTRIBUTES_UPDATE' || !context?.cart?.id)
                    return;
                const { data, errors } = await cartAttributesUpdate(context.cart.id, event.payload.attributes);
                const resultEvent = eventFromFetchResult(event, data?.cartAttributesUpdate?.cart, errors);
                send(resultEvent);
            },
            discountCodesUpdateAction: async (context, event) => {
                if (event.type !== 'DISCOUNT_CODES_UPDATE' || !context?.cart?.id)
                    return;
                const { data, errors } = await discountCodesUpdate(context.cart.id, event.payload.discountCodes);
                const resultEvent = eventFromFetchResult(event, data?.cartDiscountCodesUpdate?.cart, errors);
                send(resultEvent);
            },
            ...(onCartActionEntry && {
                onCartActionEntry: (context, event) => {
                    if (isCartActionEvent(event)) {
                        onCartActionEntry(context, event);
                    }
                },
            }),
            ...(onCartActionOptimisticUI && {
                onCartActionOptimisticUI: assign((context, event) => {
                    return onCartActionOptimisticUI(context, event);
                }),
            }),
            ...(onCartActionComplete && {
                onCartActionComplete: (context, event) => {
                    if (isCartFetchResultEvent(event)) {
                        onCartActionComplete(context, event);
                    }
                },
            }),
        },
    });
    return useMemo(() => [state, send, service], [state, send, service]);
}
export function cartFromGraphQL(cart) {
    return {
        ...cart,
        // @ts-expect-error While the cart still uses fragments, there will be a TS error here until we remove those fragments and get the type in-line
        lines: flattenConnection(cart.lines),
        note: cart.note ?? undefined,
    };
}
function eventFromFetchResult(cartActionEvent, cart, errors) {
    if (errors) {
        return { type: 'ERROR', payload: { errors, cartActionEvent } };
    }
    if (!cart) {
        return {
            type: 'CART_COMPLETED',
            payload: {
                cartActionEvent,
            },
        };
    }
    return {
        type: 'RESOLVE',
        payload: {
            cart: cartFromGraphQL(cart),
            rawCartResult: cart,
            cartActionEvent,
        },
    };
}
function isCartActionEvent(event) {
    return (event.type === 'CART_CREATE' ||
        event.type === 'CARTLINE_ADD' ||
        event.type === 'CARTLINE_UPDATE' ||
        event.type === 'CARTLINE_REMOVE' ||
        event.type === 'NOTE_UPDATE' ||
        event.type === 'BUYER_IDENTITY_UPDATE' ||
        event.type === 'CART_ATTRIBUTES_UPDATE' ||
        event.type === 'DISCOUNT_CODES_UPDATE');
}
function isCartFetchResultEvent(event) {
    return (event.type === 'RESOLVE' ||
        event.type === 'ERROR' ||
        event.type === 'CART_COMPLETED');
}
